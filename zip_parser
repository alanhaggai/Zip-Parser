#!/usr/bin/perl

use strict;
use warnings;
use Data::ParseBinary;
use Data::Dumper;

# Check if a file has been passed as an argument or not
if( @ARGV == 0 ) {
    print " No .zip file has been passed.\n";
    exit;
}

undef $/;

my $filename = shift;
open my $fh, '<', $filename or die 'can not open $filename';
binmode $fh;


#    Filename Compressed_Size Last_Mod_File_Time Last_Mod_File_Date Position Extra_Field Extra_Field_Length
my @printable_local_file_header = qw(
    Filename Extra_Field Extra_Field_Length
);

my @printable_central_directory_record = qw(
    Filename Compressed_Size Position Version_Made_By Extra_Field Extra_Field_Length
);

#    Number_Of_This_Disk Number_Of_The_Disk_With_The_Start_Of_The_Central_Directory Total_Number_Of_Entries_In_The_Central_Directory_On_This_Disk Total_Number_Of_Entries_In_The_Central_Directory Size_Of_The_Central_Directory Offset_Of_Start_Of_Central_Directory_With_Respect_To_The_Starting_Disk_Number .ZIP_File_Comment_Length .ZIP_File_Comment Position
my @printable_end_central_directory_record = qw(
);

sub printable {
    my ( $var, $header ) = @_;
    my @printable;

    if( $header eq 'lfh' ) {
        @printable = @printable_local_file_header;
    } elsif( $header eq 'cdr' ) {
        @printable = @printable_central_directory_record;
    } elsif( $header eq 'ecdr' ) {
        @printable = @printable_end_central_directory_record;
    }

    for( @printable ) {
        return 1 if($var eq $_);
    }
    return 0;
}

sub dissect {
    my ( $data, $header ) = @_;

    if( $header eq 'lfh' || $header eq 'cdr' ) {
        &mod_file_date_time($data);
        &extra_field($data);
    } else {
        $data = [$data];
    }

    for( @$data ) {
        my %temp = %$_;
    
        map {
            if( &printable($_, $header) ) {
                if( ref($temp{$_}) ne 'HASH' ) {
                    printf "%s - %s\n", $_, $temp{$_};
                } else {
                    printf "%s -", $_;
                    my %hash = %{$temp{$_}};
                    map {
                        if( ref($hash{$_}) eq 'ARRAY' ) {
                            printf "\n%s -", $_;
                            map {
                                print "\n\t$_";
                            } @{$hash{$_}};
                        } else {
                            printf "\n%s - %s", $_, $hash{$_};
                        }
                    } keys %hash;
                    print "\n";
                }
            }
        } keys %temp;

        print "\n\n";
    }
}

sub extra_field {
    my $data = shift;
    my ( @header, @data );

    my %header_mappings = (
        '0001' => 'Zip64 extended information extra field',
        '0007' => 'AV Info',
        '0008' => 'Reserved for extended language encoding data (PFS)',
        '0009' => 'OS/2',
        '000a' => 'NTFS ',
        '000c' => 'OpenVMS',
        '000d' => 'UNIX',
        '000e' => 'Reserved for file stream and fork descriptors',
        '000f' => 'Patch Descriptor',
        '0014' => 'PKCS#7 Store for X.509 Certificates',
        '0015' => 'X.509 Certificate ID and Signature for individual file',
        '0016' => 'X.509 Certificate ID for Central Directory',
        '0017' => 'Strong Encryption Header',
        '0018' => 'Record Management Controls',
        '0019' => 'PKCS#7 Encryption Recipient Certificate List',
        '0065' => 'IBM S/390 (Z390), AS/400 (I400) attributes - uncompressed',
        '0066' => 'Reserved for IBM S/390 (Z390), AS/400 (I400) attributes - compressed',
        '4690' => 'POSZIP 4690 (reserved) ',
        '07c8' => 'Macintosh',
        '2605' => 'ZipIt Macintosh',
        '2705' => 'ZipIt Macintosh 1.3.5+',
        '2805' => 'ZipIt Macintosh 1.3.5+',
        '334d' => 'Info-ZIP Macintosh',
        '4341' => 'Acorn/SparkFS ',
        '4453' => 'Windows NT security descriptor (binary ACL)',
        '4704' => 'VM/CMS',
        '470f' => 'MVS',
        '4b46' => 'FWKCS MD5 (see below)',
        '4c41' => 'OS/2 access control list (text ACL)',
        '4d49' => 'Info-ZIP OpenVMS',
        '4f4c' => 'Xceed original location extra field',
        '5356' => 'AOS/VS (ACL)',
        '5455' => 'extended timestamp',
        '554e' => 'Xceed unicode extra field',
        '5855' => 'Info-ZIP UNIX (original, also OS/2, NT, etc)',
        '6375' => 'Info-ZIP Unicode Comment Extra Field',
        '6542' => 'BeOS/BeBox',
        '7075' => 'Info-ZIP Unicode Path Extra Field',
        '756e' => 'ASi UNIX',
        '7855' => 'Info-ZIP UNIX (new)',
        'a220' => 'Microsoft Open Packaging Growth Hint',
        'fd4a' => 'SMS/QDOS',
    );

    for( my $i = 0; $i < @$data; $i++ ) {
        if( exists $data->[$i]{'Extra_Field'} ) {
            for( my $j = 0; $j < length $data->[$i]{'Extra_Field'}; $j += 4 ) {
                my $header = unpack("H4", pack('Z*', substr($data->[$i]{'Extra_Field'}, $j, 2)));
                $header = substr($header, 2, 2) . substr($header, 0, 2);

                if( exists $header_mappings{$header} ) {
                    $header = $header_mappings{$header};
                }

                push @header, $header;
                my $data = unpack("H4", pack('Z*', substr($data->[$i]{'Extra_Field'}, $j + 2, 2)));
                push @data, substr($data, 2, 2) . substr($data, 0, 2);
            }
            $data->[$i]{'Extra_Field'} = {
                Header => \@header,
                Data   => \@data,
            };
        }
    }
}

sub mod_file_date_time {
    my $data = shift;
    for( 0 .. @$data - 1 ) {
        # Convert Last Mod File Time to Hour, Minute and Second
        $data->[$_]{'Last_Mod_File_Time'} = pack('n', $data->[$_]{'Last_Mod_File_Time'});
        my $convert = BitStruct('Last_Mod_File_Time',
            BitField('Hour', 5),
            BitField('Minute', 6),
            BitField('Second', 5),
        );
        $data->[$_]{'Last_Mod_File_Time'} = $convert->parse(CreateStreamReader($data->[$_]{'Last_Mod_File_Time'}));

        # Convert Last Mod File Date to Year, Month and Day
        $data->[$_]{'Last_Mod_File_Date'} = pack('n', $data->[$_]{'Last_Mod_File_Date'});
        $convert = BitStruct('Last Mod File Date',
            BitField('Year', 7),
            BitField('Month', 4),
            BitField('Day', 5),
        );
        $data->[$_]{'Last_Mod_File_Date'} = $convert->parse(CreateStreamReader($data->[$_]{'Last_Mod_File_Date'}));
        $data->[$_]{'Last_Mod_File_Date'}{'Year'} = $data->[$_]{'Last_Mod_File_Date'}{'Year'} + 1980;
    }
}

# Zip is little endian

my $parser_end_central_directory_record = Struct('zip',
    Const(Bytes('End_Of_Central_Dir_Signature', 4), "\x50\x4B\x05\x06"),
    Anchor('Position'),
    ULInt16('Number_Of_This_Disk'),
    ULInt16('Number_Of_The_Disk_With_The_Start_Of_The_Central_Directory'),
    ULInt16('Total_Number_Of_Entries_In_The_Central_Directory_On_This_Disk'),
    ULInt16('Total_Number_Of_Entries_In_The_Central_Directory'),
    ULInt32('Size_Of_The_Central_Directory'),
    ULInt32('Offset_Of_Start_Of_Central_Directory_With_Respect_To_The_Starting_Disk_Number'),
    ULInt16('.ZIP_File_Comment_Length'),
    Field('.ZIP_File_Comment', sub { $_->ctx->{'.ZIP_File_Comment_Length'} }),
);

seek $fh, -22, 2;
my $stream = CreateStreamReader(File => $fh);
my $number_of_files;
my $pecdr = $parser_end_central_directory_record->parse($stream);
&dissect($pecdr, 'ecdr');
$number_of_files = $pecdr->{'Total_Number_Of_Entries_In_The_Central_Directory'},

my $parser_local_file_header = Array($number_of_files,
    Struct('zip',
        Const(Bytes('Local_File_Header_Signature', 4), "\x50\x4B\x03\x04"),
        Pointer( sub { 0 }, Bytes("\x50\x4B\x03\x04", 4)),
        ULInt16('Version_Needed_To_Extract'),
        ULInt16('General_Purpose_Bit_Flag'),
        ULInt16('Compression_Method'),
        ULInt16('Last_Mod_File_Time'),
        ULInt16('Last_Mod_File_Date'),
        ULInt32('CRC-32'),
        ULInt32('Compressed_Size'),
        ULInt32('Uncompressed_Size'),
        ULInt16('Filename_Length'),
        ULInt16('Extra_Field_Length'),
        String('Filename', sub { $_->ctx->{'Filename_Length'} }),
        Field('Extra_Field', sub { $_->ctx->{'Extra_Field_Length'} }),
        #Array(sub { $_->ctx->{'Extra_Field_Length'} / 2 }, ULInt16('Header'), ULInt16('Data')),
        # Add an array for header[] and data[]
        Field('Compressed_Data', sub { $_->ctx->{'Compressed_Size'} }),
        Anchor('Position'),
    ),
);

my $parser_central_directory_record = Array($number_of_files,
    Struct('zip',
        Const(Bytes('Central_File_Header_Signature', 4), "\x50\x4B\x01\x02"),
        Struct('Version_Made_By',
            ULInt8('Specification'),
            ULInt8('Compatibility'),
        ),
        ULInt16('Version_Needed_To_Extract'),
        ULInt16('General_Purpose_Bit_Flag'),
        ULInt16('Compression_Method'),
        ULInt16('Last_Mod_File_Time'),
        ULInt16('Last_Mod_File_Date'),
        ULInt32('CRC-32'),
        ULInt32('Compressed_Size'),
        ULInt32('Uncompressed_Size'),
        ULInt16('Filename_Length'),
        ULInt16('Extra_Field_Length'),
        ULInt16('File_Comment_Length'),
        ULInt16('Disk_Number_Start'),
        ULInt16('Internal_File_Attributes'),
        ULInt32('External_File_Attributes'),
        ULInt32('Relative_Offset_Of_Local_Header'),
        String('Filename', sub { $_->ctx->{'Filename_Length'} }),
        Field('Extra_Field', sub { $_->ctx->{'Extra_Field_Length'} }),
        Field('File_Comment', sub { $_->ctx->{'File_Comment_Length'} }),
    ),
);

seek $fh, 0, 0;
$stream = CreateStreamReader(File => $fh);
&dissect($parser_local_file_header->parse($stream), 'lfh');
&dissect($parser_central_directory_record->parse($stream), 'cdr');
